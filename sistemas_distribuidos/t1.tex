\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{longtable}

\geometry{a4paper, margin=1in}

\title{Transações e Controle de Concorrência em Sistemas Distribuídos}
\author{Resumo Analítico}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este artigo resume os conceitos fundamentais de transações e controle de concorrência em sistemas distribuídos (SD), focando na necessidade de garantir a integridade e a consistência dos dados em ambientes caracterizados por concorrência e falhas parciais. São abordados os mecanismos de serialização, os métodos de controle de concorrência (travamento, otimista e carimbo de tempo) e os protocolos essenciais para transações distribuídas, como o Protocolo de Confirmação de Duas Fases (2PC). Finalmente, é apresentado um cenário prático para ilustrar a aplicação e os desafios desses conceitos em sistemas de alta demanda.
\end{abstract}

\section{Transações e Consistência}

Em sistemas distribuídos, uma \textbf{transação} é uma sequência de operações sobre recursos compartilhados, especificadas por um cliente para serem executadas como uma \textbf{unidade indivisível} \cite{604, 605, 615}. A função principal das transações é garantir que os dados gerenciados por um servidor sejam transformados de um \textbf{estado consistente} para outro \cite{603}.

A atomicidade da transação é crucial, garantindo que as operações sejam atômicas diante de falhas de clientes e servidores \cite{615}. Isso implica que o resultado da transação deve ser:
\begin{enumerate}
    \item \textbf{Serialmente Equivalente:} A execução interposta de operações feitas por clientes concorrentes deve ser equivalente a alguma ordem serial (sequencial) dessas transações \cite{431, 605, 602, 615}.
    \item \textbf{Recuperável:} As operações devem ser totalmente concluídas com êxito (\textit{commit}) e gravadas permanentemente (\textit{durabilidade}), ou não devem ter \textbf{nenhum efeito} (\textit{abort}) se houver falhas \cite{605}.
\end{enumerate}

Os sistemas de transação lidam tipicamente com \textbf{falhas por colapso de processo} (servidores falham) e \textbf{falhas por omissão na comunicação} \cite{604, 387}. A durabilidade e a recuperação dependem de \textbf{objetos recuperáveis}, que são aqueles cujas alterações podem ser restauradas para refletir apenas as transações confirmadas, mesmo após uma falha \cite{388, 389}.

\subsection{Transações Aninhadas}

Transações aninhadas (\textit{nested transactions}) são estruturadas a partir de outras subtransações \cite{432, 615}. Elas são particularmente úteis em sistemas distribuídos, pois permitem que as subtransações descendentes sejam executadas \textbf{concorrentemente em servidores diferentes}, proporcionando uma \textbf{maior concorrência} \cite{432, 615}.

\section{Controle de Concorrência (CC)}

Os protocolos de Controle de Concorrência são baseados no critério da \textbf{equivalência serial} e utilizam regras de conflito entre operações para garantir que as transações sejam serializáveis \cite{615}. Para que isso funcione, os desenvolvedores de aplicações distribuídas devem garantir que a execução de transações seja \textbf{restrita}, o que significa atrasar operações de leitura e escrita sobre um objeto até que todas as transações que escreveram nesse objeto tenham sido confirmadas ou canceladas \cite{390, 407}.

Os três métodos de CC mais importantes são \cite{615, 602}:

\begin{enumerate}
    \item \textbf{Travamento (\textit{Locking}):} É o método predominante de CC \cite{602, 615}. Requer o uso de \textbf{travas exclusivas} para operações de escrita e travas compartilhadas para leitura \cite{434}. Para garantir a serialização, é utilizado o \textbf{Travamento de Duas Fases Restrito} (\textit{Restricted Two-Phase Locking}), que impõe que as travas de uma transação sejam \textbf{mantidas até que a transação seja confirmada ou cancelada} \cite{616, 437}.
        \begin{itemize}
            \item O inconveniente principal é a possibilidade de \textbf{impasses} (\textit{deadlocks}) \cite{430, 615}.
            \item A concorrência pode ser aumentada pelo \textbf{Travamento de Duas Versões}, no qual a trava exclusiva (\textit{commit lock}) é retardada até a confirmação da transação \cite{397, 399}.
        \end{itemize}
    \item \textbf{Controle de Concorrência Otimista (CCO):} Assume que os conflitos são raros \cite{458, 609, 615}. As transações procedem até estarem prontas para a confirmação, quando passam pela \textbf{validação} \cite{615, 617}. A validação verifica se as operações da transação (\(T_v\)) conflitam com outras transações sobrepostas (\(T_i\)) \cite{617, 400}. Se houver conflito, a transação é cancelada (podendo ser reiniciada) \cite{609, 444}. O CCO utiliza a \textbf{validação para trás} (em relação a transações confirmadas) ou \textbf{para frente} (em relação a transações ativas) \cite{401}.
    \item \textbf{Ordenação por Carimbo de Tempo (\textit{Timestamp Ordering}):} Atribui um carimbo de tempo (\textit{timestamp}) exclusivo a cada transação no início, garantindo que as operações sejam executadas na ordem dos tempos iniciais \cite{610, 615}. Se uma operação violar a ordem temporal, a transação é \textbf{cancelada} \cite{447, 451, 456, 459}. A \textbf{Ordenação por Carimbo de Tempo de Versão Múltipla} é uma variação eficiente, pois permite manter versões antigas confirmadas de objetos, evitando que operações de leitura tardias sejam rejeitadas \cite{405, 406}.
\end{enumerate}

\section{Transações Distribuídas e Protocolo de Confirmação}

Uma transação se torna \textbf{distribuída} se acessa objetos gerenciados por \textbf{vários servidores diferentes} \cite{616, 728}. A atomicidade exige que todos os servidores envolvidos \textbf{confirmem-na ou cancelem-na} \cite{616, 615}. Para garantir o acordo, um servidor atua como \textbf{coordenador} para o \textbf{Protocolo de Confirmação Atômica} \cite{731, 413}.

\subsection{Protocolo de Confirmação de Duas Fases (2PC)}

O 2PC é o protocolo atômico mais comum para TDs \cite{615, 731, 620}.

\begin{enumerate}
    \item \textbf{Fase de Votação (\texttt{canCommit?})}: O coordenador envia a requisição \texttt{canCommit?} aos participantes \cite{731}. Um participante só vota \textbf{Sim} se estiver \textbf{preparado para confirmar}, o que exige salvar todas as alterações da transação no armazenamento permanente (log) \cite{617, 732}. Se o participante votar Não, ele cancela imediatamente \cite{731, 620}.
    \item \textbf{Fase de Conclusão (\texttt{doCommit/doAbort})}: O coordenador reúne os votos \cite{620}. Se \textbf{todos} votarem Sim, o coordenador decide confirmar (\texttt{doCommit}); caso contrário, ele decide cancelar (\texttt{doAbort}) \cite{731}.
\end{enumerate}

O log do servidor deve armazenar informações sobre o \textbf{status da transação} (preparada, confirmada, cancelada) e as \textbf{listas de intenções} (\textit{intentions lists}) \cite{419}. Isso é fundamental para a \textbf{recuperação}, garantindo que, mesmo em sistemas assíncronos e com falhas de colapso, os servidores falhos possam ser substituídos e consigam alcançar um consenso sobre o resultado das transações \cite{431, 620}.

\subsection{Impasses Distribuídos}

O uso de travamento em TDs pode gerar \textbf{impasses distribuídos}, que ocorrem se houver um ciclo no \textbf{grafo espera por} (*wait-for graph*) que abranja objetos em vários servidores \cite{410, 743}. A detecção de impasses envolve métodos como o \textbf{caminhamento pelas arestas} (*edge chasing*), onde mensagens de sondagem (*probe*) seguem as arestas do grafo espera por global \cite{415}.

\section{Aplicação Prática em Ambientes de Alta Demanda}

Os princípios de CC e transação são essenciais para manter a \textbf{integridade dos dados} e o \textbf{desempenho} em cenários de alta concorrência \cite{1}.

\subsection{Lições do Cenário de Laboratório (Rinha de Backend)}

O desafio da Rinha de Backend 2025, um teste de \textbf{performance e resiliência em sistemas distribuídos} sob \textbf{limites rígidos de CPU e memória} \cite{1}, serve como um exemplo prático das dificuldades de implementar esses conceitos:

\begin{enumerate}
    \item \textbf{Compromisso entre Consistência e Escalabilidade:} A meta de obter o "menor tempo de resposta e máxima confiabilidade" exige um equilíbrio delicado \cite{1}. O uso de um SGBD robusto como o Postgres, que oferece fortes garantias ACID (incluindo Isolamento, geralmente via travamento), pode falhar sob alta carga devido a gargalos de memória e CPU ("uso de memória explodia") \cite{3}. A busca por \textbf{escalabilidade} frequentemente leva a soluções que flexibilizam as garantias de consistência estrita (como o uso do Redis em memória).
    \item \textbf{Controle de Concorrência e Recursos Limitados:} Em ambientes distribuídos com recursos restritos (1.5 vCPU, 350 MB), a tentativa de maximizar a concorrência pode levar a inconsistências. A otimização exige não apenas protocolos de CC eficientes, mas também o \textbf{ajuste do nível de concorrência interna} (e.g., limitando o número de *workers* ativos) para garantir que cada processo "tenha tempo e recurso suficiente para finalizar o seu trabalho", preservando a integridade dos dados.
\end{enumerate}

\begin{center}
    *O cenário da Rinha demonstrou que as decisões de arquitetura e otimização são um constante \textit{trade-off} entre o rigor teórico dos protocolos de transação e as limitações práticas de recursos e desempenho, confirmando que a implementação de sistemas distribuídos exige uma profunda compreensão das consequências dessas escolhas \cite{1}.*
\end{center}

\newpage
\begin{thebibliography}{99}
\bibitem[1]{1} Excerpts from the transcript of the video "Como Venci a Rinha de Backend 2025" uploaded on the YouTube channel "Lucas Montano".
\bibitem[2]{3} Excerpts from "GitHub - zanfranceschi/rinha-de-backend-2025: Rinha de Backend - Terceira Edição".
\bibitem[3]{387} Coulouris, G., Dollimore, J., Kindberg, T., \& Blair, G. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto} (5ª ed.). Capítulo 16, Introdução (Modelo de Falha).
\bibitem[4]{388} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Objetos Recuperáveis.
\bibitem[5]{389} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Propriedades ACID.
\bibitem[6]{390} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Execuções Restritas de Transações.
\bibitem[7]{397} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Aumento da concorrência em esquemas de travamento.
\bibitem[8]{399} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Travamento de Duas Versões.
\bibitem[9]{400} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Regras de Conflito para Validação.
\bibitem[10]{401} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Validação Otimista (Para Trás e Para Frente).
\bibitem[11]{405} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Ordenação por Carimbo de Tempo de Versão Múltipla.
\bibitem[12]{406} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Concorrência na Ordenação por Carimbo de Tempo.
\bibitem[13]{407} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Resumo, Recuperação e Versões de Tentativa.
\bibitem[14]{410} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Impasses Distribuídos.
\bibitem[15]{413} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 17, Transações Distribuídas (Coordenador e Participantes).
\bibitem[16]{415} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 17, Caminhamento pelas Arestas.
\bibitem[17]{419} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 17, Entradas no Arquivo de Recuperação.
\bibitem[18]{430} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Introdução ao Controle de Concorrência.
\bibitem[19]{431} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Serialização.
\bibitem[20]{432} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Transações Aninhadas.
\bibitem[21]{434} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Tipos de Travamento (Leitura e Escrita).
\bibitem[22]{437} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Travamento de Duas Fases Restrito.
\bibitem[23]{444} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Validação.
\bibitem[24]{447} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Carimbo de Tempo.
\bibitem[25]{451} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Ordenação por Carimbo de Tempo.
\bibitem[26]{453} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Versão Múltipla.
\bibitem[27]{456} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Cancelamento por Carimbo de Tempo.
\bibitem[28]{458} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Controle de Concorrência Otimista.
\bibitem[29]{459} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Comparação dos Métodos.
\bibitem[30]{602} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Introdução.
\bibitem[31]{603} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Objetivos das Transações.
\bibitem[32]{604} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Modelo de Falha.
\bibitem[33]{605} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Propriedades da Transação.
\bibitem[34]{609} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Controle de Concorrência Otimista.
\bibitem[35]{610} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16, Ordenação da Indicação de Tempo.
\bibitem[36]{615} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 16 (Tema 5), Visão Geral.
\bibitem[37]{616} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 17, Transações Distribuídas (Definição e Coordenador).
\bibitem[38]{617} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 17, Protocolo 2PC (Fases).
\bibitem[39]{618} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 17, Log de Recuperação.
\bibitem[40]{620} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 17, Protocolo 2PC (Exercício - Definição).
\bibitem{728} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 17, Introdução (Transações Distribuídas).
\bibitem{731} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 17, Protocolos de Confirmação Atômica.
\bibitem{732} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 17, Voto em 2PC.
\bibitem{743} Coulouris, G., et al. (2013). \textit{Sistemas Distribuídos: Conceitos e Projeto}. Capítulo 17, Impasses Distribuídos.
\end{thebibliography}

\newpage
\begin{appendix}
\section{Apêndices: Excertos das Fontes}

\begin{Verbatim}[frame=single, label={Excertos da Fonte: Sistemas Distribuídos, 5ª Edição (Coulouris et al.)}]
[18] Todos os protocolos de controle de concorrência são baseados no critério da equivalência serial e são distintos por regras de conflitos entre operações. Serão descritos três métodos:
[19] O controle de concorrência é o que é usado para garantir a serialização das transações, evitando os problemas que surgem de execuções concorrentes. ... Para que a execução concorrente seja correta, ela deve ser serialmente equivalente, o que significa que todos os pares de operações conflitantes de duas transações devem ser executados na mesma ordem em todos os objetos que ambas acessam.
[20] As transações aninhadas (nested transactions) estendem o conceito de transação, permitindo que as transações sejam estruturadas a partir de conjuntos de outras subtransações. A transação mais externa é chamada de transação de nível superior e as demais são subtransações. ... As transações aninhadas são úteis em sistemas distribuídos, pois as subtransações descendentes podem ser executadas concorrentemente em servidores diferentes, permitindo uma maior concorrência.
[21] O uso de travas exclusivas (para operações de escrita) e travas compartilhadas (para operações de leitura) para garantir a serialização é chamado de travamento (locking).
[22] As regras para o uso de travas em uma implementação do travamento de duas fases restrito estão resumidas na Figura 16.16. ... O travamento é realizado quando os pedidos de operações de leitura e de escrita estão para ser aplicados aos objetos recuperáveis e o destravamento é realizado pelas operações de confirmação ou cancelamento do coordenador de transação.
[23] O controle de concorrência otimista é baseado no pressuposto de que os conflitos entre transações são raros. As transações são executadas sem verificação de conflito imediata, e a serialização só é verificada na fase de validação, antes da confirmação. Se a validação falhar, a transação é cancelada.
[24] A ordenação por carimbo de tempo é uma alternativa para o controle de concorrência. Cada transação recebe um carimbo de tempo exclusivo ao ser iniciada, o qual define sua ordem de precedência. ... As operações são validadas ao serem executadas; se a operação violar a ordem dos carimbos de tempo, a transação é cancelada.
[25] A ordenação por carimbo de tempo usa o carimbo de tempo da transação para decidir se cada operação em um objeto pode prosseguir.
[26] A Ordenação por Carimbo de Tempo de Versão Múltipla melhora a concorrência e o desempenho, pois permite que as operações de leitura raramente sejam rejeitadas.
[27] A requisição de uma transação para ler um objeto é aceita somente se a transação com carimbo de tempo maior ainda não tiver escrito a versão de tentativa correspondente.
[28] O controle de concorrência otimista é projetado para evitar as desvantagens do travamento e da ordenação por carimbo de tempo.
[29] O travamento de duas fases é o método de controle de concorrência mais amplamente usado em sistemas distribuídos. ... A ordenação por carimbo de tempo de versão múltipla é mais complexa, mas não sofre de impasses.
[30] Este capítulo discute a aplicação de transações e controle de concorrência em objetos compartilhados gerenciados por servidores.
[31] O objetivo das transações é garantir que todos os objetos gerenciados por um servidor permaneçam em um estado consistente ao serem acessados por várias transações e na presença de falhas do servidor.
[32] O modelo de falha para transações tipicamente lida com falhas por colapso de processos e falhas por omissão na comunicação, mas não com qualquer tipo de comportamento arbitrário (ou bizantino).
[33] Uma transação é especificada por um cliente como um conjunto de operações sobre os objetos a serem executadas como uma unidade indivisível pelos servidores que estão gerenciando esses objetos. As transações de um cliente também são consideradas indivisíveis do ponto de vista das transações dos outros clientes, no sentido de que as operações de uma transação não podem observar os efeitos parciais das operações de outra.
[34] O controle de concorrência otimista é baseado na suposição de que os conflitos entre transações são raros.
[35] A ordenação por carimbo de tempo (timestamp) ordena as transações que acessam os mesmos objetos de acordo com seus tempos iniciais.
[36] Transações e Controle de Concorrência. Uma transação define uma sequência de operações no servidor que garante que elas sejam atômicas na presença de várias falhas de clientes e de servidor. ... Todos os protocolos de controle de concorrência são baseados no critério da equivalência serial e são distintos por regras de conflitos entre operações. Serão descritos três métodos.
[37] O coordenador que abriu a transação torna-se o coordenador da transação distribuída e, no final, é responsável por confirmá-la ou cancelá-la. ... Cada um dos servidores que gerencia um objeto acessado por uma transação é um participante da transação.
[38] O teste de validação na transação Tv é baseado no conflito entre operações em pares de transação Ti e Tv.
[39] As transações se tornam duráveis pelo estabelecimento de pontos de verificação e pelo registro em um arquivo de recuperação, que é usado para recuperação quando um servidor é substituído após uma falha.
[40] Um protocolo de confirmação de três fases tem as seguintes partes: Fase 1: é igual à confirmação de duas fases. ... Explique como esse protocolo evita o atraso para os participantes durante seu período de incerteza, devido à falha do coordenador ou de outros participantes. Presuma que a comunicação não falhe.
 Este capítulo se preocupa com o gerenciamento de transações que envolvem vários servidores de objetos recuperáveis.
 Um servidor atua como coordenador para garantir o mesmo resultado em todos os participantes, utilizando um protocolo de confirmação atômica. ... O Protocolo de Confirmação de Duas Fases (2PC) é o protocolo atômico de confirmação mais comumente usado em transações distribuídas.
 Um participante só vota Sim se estiver preparado para confirmar, o que exige salvar todas as alterações da transação no armazenamento permanente.
 O travamento de duas fases garante a serialização, mas, em transações distribuídas, surge a possibilidade de impasses distribuídos.
\end{Verbatim}

\begin{Verbatim}[frame=single, label={Excertos da Fonte: Vídeo "Como Venci a Rinha de Backend 2025"}]
[1] a rinha de backend foi um desafio de performance e resiliência em sistemas distribuídos onde a meta era processar um volume massivo de pagamentos com menor tempo de resposta e máxima confiabilidade sabe que essas duas coisas aqui é sempre um equilíbrio né é muito equilíbrio tipo é difícil tu ter 100% de confiabilidade e sem e um tempo 100% melhor tá ligado bom 100% melhor é ruim de dizer mas enfim tu entendeu dentro dos limites rígidos de CPU e memória
[2] A Rinha de Backend é um desafio em que é necessário desenvolver uma solução backend em qualquer tecnologia e tem como principal objetivo o aprendizado e compartilhamento de conhecimento!
\end{Verbatim}

\end{appendix}

\end{document}